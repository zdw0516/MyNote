### Object对象

​		使用基本数据类型数据，我们所穿件的变量都是独立，不能成为一个整体。对象是一种复合数据类型，对小囊肿可以保存多个不同的数据类型。

- 对象的分类

  1. 内建对象

     1. 比如math，String，Boolean，Function....

  2. 宿主对象

     由js的运行环境提供的对象，目前来讲主要是指浏览器提供的对象

     - 比如DOM，BOM。

  3. 自定义对象

     由开发人员自己创建的对象

### 创建对象

​		var obj = new Object（） 使用new关键字调用的函数，来构造对象。我们可以向对象中添加属性。

**向对象中添加属性**

- 语法：对象.属性名. = 属性值
  - obj.name = "小明"

**读取对象中的属性**

- 语法：对象.属性名
  - 如果读取对象中没有的属性，不会报错，而是报undefined

**修改对象的属性值**

- 语法：对象.属性名 = 新值

**删除对象的属性**

- 语法：delete 对象.属性名
  - delete obj.name

### 属性名和属性值

- ​	属性名
  - 对象的属性名不强制要求遵守标识符规范，但是我们还是尽量按照标识符的规范去做
  - 如果采用特殊的属性名，不能采用.的方式去操作。需要另一种方式：
    - 语法：对象["属性名"] = 属性值
    - 这样存对象的属性值，取的时候也要按照这种方式去取  对象["属性名"]    使用[]这种方式更加的灵活。在[]中可以传递一个变量，这个变量值是多少就会去读取那个属性
      -  obj["123"] = "789"
      - var a = "123"
      - console.log(obj[a])  读取的是“789"

- 属性值

  - js对象的属性值，可以是任意的数据类型，甚至可以是一个对象
  - in 运算符  
    - 通过该运算符可以检查一个对象中是否含有指定的属性，如果有返回true，反之返回false。
    - 语法：”属性名“ in 对象

  ### 基本数据类型和引用数据类型

  ​		基本数据类型：string，number，Boolean，null，undefined

  ​		引用数据类型：object

  JS中的变量都是保存在栈内存中的

  - ​	基本数据类型直接在栈内存中存储，值与值之间独立存在，修改一个变量不会影响另一个变量
    - 引用数据类型，引用数据类型是直接保存在堆内存中，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象的引用，当通过一个变量修改属性时，另一个也会收到影响。
    - 当我们比较两个基本数据类型时，我们比较的是两个数值，当我们比较两个引用数据类型，比较的是两个内存地址

### 对象字面量

​		使用字面量创建一个对象

- ​	语法: var a = {};            优点：使用字面量创建对象时，直接指定对象中的属性。 
- 语法：{属性名：属性值，属性名：属性值。。。。} 
  - 属性名和属性值是一组一组的名值对结构。

### 函数 

​		函数也是一个对象，可以封装一些代码，在需要的时候调用。

- 创建一个函数对象

  - var a =new Function（）
    - 可以将要封装的代码以字符串的形式传递给构造函数。调用函数语法：函数名（）
    - 函数具有所有对象的功能。可以赋值。
  - 使用函数声明来构造一个函数
    - 语法：function 函数名（形参）{

  ​				代码块

  ​																	}

  - 使用函数表达式创建一个函数

    - var 函数名 = function（）{

      ​			函数体

      ​												}

    - 调用函数时，多余的实参不会报错。但是没用。如果实参少于形参的数量，结果会是undefined。解析器不会检查形参的类型。

### 返回值

​		return设置函数的返回值

​		语法：

- ​		return 值
  - 在函数中，return后的语句都不会执行
  - 如果函数中没有return后面不接值或者函数中没有return 那么就会返回undefined。
- 实参可以是任何数据类型，实参可以是一个对象，也可以是一个函数，当我们函数的参数过多，我们可以把参数封装到一个对象中，然后把这个对象传入到函数的形参中。在函数中，我们可以通过调用属性的方法进行传参。函数的返回值可以是任意类型。

### 立即执行函数

​	函数定义完立即被调用，立即执行函数往往执行一次。

### 方法

​	函数也可以是对象的属性，如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法，调用函数就是调用对象的方法。

- 调用方法和调用函数没有其他的区别，只是叫法不同。

### 枚举对象中的属性

​		使用for .....in 语句

- ​		语法：

  - for （var 变量 in 对象）{

    ​                  

     										}

    for ...in 语句 对象中有几个属性，循环体就会执行几次，每次执行时，会将对象中的一个属性的名字赋值给这个变量

### 作用域

​		作用域指的是一个变量的作用范围。在JS中有两种作用域，全局作用域，一个函数作用域。

- 全局作用域

  - 直接编写在script标签中的js代码，都在全局作用域，全局作用域在页面打开时创建，在页面关闭时销毁。在全局作用域有一个全局对象window，他代表的是一个浏览器窗口，它由浏览器创建，我们可以直接使用。在全局作用域中：我们创建的变量都会作为window对象的属相保存。全局中创建的函数，都会作为window的方法保存。

    -  变量的声明提前
      
  - 使用var关键字声明的变量，会在所有的代码执行前被声明(但是不会被赋值)，但是如果声明变量时不使用var关键字，则变量不会被声明提前。
      
  - 函数的声明提前
    
      使用函数声明形式创建的函数function 函数名 （）{}   会在代码执行前被创建

- 函数的作用域
  - 调用函数时创建函数的作用域，调用后作用域销毁。每调用一次函数，就会创建一个新的函数作用域。他们之间是相互独立的。在函数的作用域中可以访问到全局作用域。在全局作用域中无法访问到局部的作用域。
    - 当在函数中操作变量时，会在函数中寻找。如果没有就从它上一级去寻找。
    - 在函数中如果想要访问全局中的变量，需要使用window.变量名
    - 在函数作用域中也有声明提前
    - 在函数中声明变量的时候如果没有var ，如果函数中没有会被当做全局变量，如果有会修改函数中的变量
    - 形参就相当于在声明变量
  
  ### debug
  
  ​		调试器，谷歌，火狐，IE。都支持调试
  
  ### this
  
  解析器在调用函数每次都会想函数的内部传递一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的上下文对象，根据函数的调用方式不同，this会指向不同的对象。
  
  - ​	以函数的形式调用，this就是window
  - ​    以方法的形式调用，this就是obj（对象 ）
  
  ### 对象的补充
  
  ​	使用工厂方法创建对象，新建一个函数，在函数的内部我们新建一个对象，然后对象的属性值我们可以通过函数的变量从外部传进来，从而达到创建大批的对象。
  
  ​	但是我们通过这种方法创建的对象，无法进行区分。因为类型都是object （都是通过 var obj = new Object（）创建）。
  
  ### 构造函数 
  
   		创建一个构造函数，专门用来创建Person对象的，构造函数就是一个普通的函数，创建方式和普通函数没有啥区别，不同的是构造函数习惯首字母大写。其次构造函数和普通函数的调用方式不同，普通函数直接调用，构造函数需要使用new 关键字调用。
  
  - 构造函数的执行流程
    - 立刻创建一个新的对象
    - 将新建的对象设置为函数中的this，在构造函数的内部可以引用新建的对象
    - 逐行执行代码
    - 将新建的对象作为返回值返回
    - 只要通过同一个构造函数构造出来的对象，就属于同一个类，构造函数出来的各个对象，就叫做这个类的实例。
  
  - instanceof   使用instanceof可以检查一个对象是否是一个类的实例
    - 语法：
      - 对象 instanceof 构造函数
      - 如果是就返回true，否则就返回false
  
  #### this的情况：
  
  - ​		当以函数的形式调用时，this指代的是window
  - ​        当以方法的形式调用时，this指代的就是调用该方法的对象
  - ​        当以构造函数的形式调用this，this指代的是新创建的那个对象

### 	原型（prototype）

​					我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象就是我们的原型对象。如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的对象都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过 __Proto__      来访问该属性。

- ​		原型对象
  - 原型对象就相当于一个公共的区域，所有同一类的实例都可以访问到这个原型对象，我们可以将对象中的共有内容，统一设置到原型对象中。当我们访问一个对象的属性或者方法时，先从该对象里面去找，如果没有，就回去该对象的原型对象中去找。以后我们创建构造函数时，可以将这些对象的共有的方法添加到原型对象中。
  - 使用in检查对象中是否有某个属性时，如果对象中没有就会去原型中去寻找。
  - 可以使用对象的hasownproperty（）来检查自身是否含有某个属性
  - 原型对象也是对象，所以他也有原型
    - 当我们使用一个对象的属性或者方法时，会在自身中寻找，如果自身有，则直接使用。如果没有就去原型中找，如果原型中没有，就去原型中的原型去寻找。

### toString（）

​	当我们直接在页面打印一个对象时，实际上是输出对象的toString（）方法的返回值。如果我们希望在输出对象时不输出【object object】我们可以修改。修改方法跟修改属性时一样。因为对象的toString（）方法存在于对象的二级原型中。

### 垃圾回收（GC）

​		就像人生活时间长产生垃圾一样，程序运行过程中也会产生垃圾。所以我们需要一个垃圾回收机制。否则会导致程序变慢。当一个对象没有任何变量或者属性对他进行引用，此时我们永远无法操作该对象。此时这个对象就是一个垃圾，这种对象过多就会占用大量的内存空间，导致程序无法正常运行，所以这种垃圾必须被回收。

​		在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作。我们要做的只是将我们不再使用的对象设置为null即可。



### 数组array

​	数组也是一个对象，他和我们普通对象的功能类似，也是用来存储一些值的，不同的是普通对象是使用字符串作为属性名，而数组是使用数字作为索引来操作元素。

索引：从0开始的整数就是索引

数组的存储性能比普通对象好，在开发中我们经常使用数组来存储一些数据。



- 创建数组对象

  - var arr = new Array（）

- 向数组填加元素

  - arr[0] = 10； 向数组中为0的位置添加一个10元素

- 读取索引的元素

  - arr[0]        读取数组索引为0的元素。如果读取不存在的索引，会返回undefined

- 获取数组的长度

  - arr.length

    - 对于连续的数组，使用length可以获取到数组的长度（元素的个数）
    - 对于非连续的数组，使用length获取到最大的索引+1
      - 尽量不要创建非连续的数组
    - 修改length
      - arr.length = 10; 修改数组的长度为10
      - 如果修改数组的长度小于我们的原长度，则多出的长度会被删除

    - ​	向数组的最后一个位置添加
      - arr[arr.length] = 值; 

  ### 使用字面量来创建数组

  - ​	语法：

    -  var a = []

  - 使用构造函数来创建数组

    - ​	创建数组并添加元素

    - var b = new Array（1,2,3）
    - ​    创建一个数组，数组中只有一个元素10
    - var b = [10]
    - ​    创建一个长度为10的数组
    - arr = new Array（10）；

  - 数组中的元素可以使任意的数据类型，也可以是对象

  ### 数组的方法

  - ​	push  该方法可以向数组末尾添加一个或者多个元素，并返回数组的长度，可以将添加的元素作为方法的参数传递，这样元素就会自动添加到数组的末尾，该方法会将新数组长度返回
  - ​    pop  该方法可以删除数组的最后一个元素，并返回该元素
  - ​    unshift   向数组的开头添加一个或者多个元素，并返回新数组的长度，像前面插入元素以后，其他元素的索引会依次调整
  - ​    shift  可以删除数组的第一个元素，并返回该元素
  - ​    slice（）可以用来从数组提取指定元素，该方法不会改变原数组。
    - 参数
      - 截取开始位置的索引，包含开始索引
      - 截取结束位置的索引，不包含结束索引
        - 第二个参数可以省略不写，此时可以截取从开始到最后的索引
    - 索引可以是一个负值，如果传递一个负值，则从最后往前数

  - ​    splice（）  可以删除数组中的指定元素，并将删除元素作为返回值返回，并向数组添加新元素
    - 使用splice会影响原数组
    - 参数：
      - 第一个是开始位置的索引
      - 第二个，表示删除的数量
      - 第三个及以后，可以传递一些新的元素。这些元素将会自动插入到开始位置索引的前面

  ### 数组的遍历

  ​	所谓的遍历数组，就是将数组的所有元素取出来。一般使用for循环

  - for each

    - 一般我们使用for循环去遍历数组，JS还提供了一个方法用来遍历数组。

    - for Each（）方法需要一个函数作为参数

      - 像这种函数有我们创建不由我们调用，我们称之为回调函数

      - 语法 ：

        - arr.for Each(function(){

             			语句				 })

          - 数组中有几个元素，函数就执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参，来读取这些内容。浏览器会在回调函数中传递三个函数。	
            - 第一个参数就是当前遍历到的元素
            - 第二个参数是正在遍历元素的索引
            - 第三个是正在遍历的数组。
            - IE8以下不支持该方法

  ### 数组的剩余方法

  - ​	concat（参数） 可以连接两个或者多个数组，并将新的数组返回

    - 语法：
      - arr.concat（arr2，元素）
      - 参数不仅可以传入数组，而且可以传入元素
      - 该方法不会改变原数组

  - join（）  可以将数组转换为一个字符串，不会改变原数组

    - 在join（参数）中可以指定一个字符串作为参数，这个字符串会将数组中的元素连接起来

  - reverse（） 该方法用来反转数组，该方法改变原数组

  - sort（） 对数组的顺序进行排序，也会影响原数组

    - arr.sort（）默认顺序排列，unicode编码排序，即使对于纯数字的数组，也会按照Unicode编码排序，所以可能出现错误。

    - 我们可以自己来指定排序的规则，我们可以在sort（）中设置一个回调函数，回调函数中需要设置两个形参，浏览器会去分别使用数组中的元素作为实参去调用回调函数。

      ​	使用哪个元素调用不确定，但是肯定是在数组中a在b的前面

      浏览器会根据回调函数的返回值来决定元素的顺序

      - ​	如果返回一个大于0的，则元素交换位置  
      - ​    如果返回一个小于0的，则元素位置不变
      - ​    如果返回一个等于0的，则元素位置不变